MAX_DEPTH::Int = 75

# Returns the number of stones generated by this stone at each blink count to the max depth
function expandstone(n::Int, depth::Int, cache::Dict{Tuple{Int,Int},Int}, cache_lock::ReentrantLock)
    if depth >= MAX_DEPTH
        return []
    end

    # Check if we've seen this stone before with the same blink count
    n_blinks = MAX_DEPTH - depth
    n_generated = zeros(Int, n_blinks)
    lock(cache_lock) do
        # If we've cached this stone with the same blink count,
        # we've also cached all blink counts below it (see caching logic below)
        if (n,n_blinks) ∈ keys(cache)
            for i_blink in 1:n_blinks
                n_generated[i_blink] = cache[(n,i_blink)]
            end
        end
    end
    # Stones can't disappear, so we can use the zero initialization as a check
    if n_generated[1] != 0
        return n_generated
    end

    if n == 0
        n_generated[1] = 1
        # This is fine for n_blinks=1 since the expandstone return will be empty
        n_generated[2:end] = expandstone(1, depth+1, cache, cache_lock)
    elseif length(repr(n)) % 2 == 0
        midpoint = length(repr(n))÷2
        n1 = parse(Int, repr(n)[1:midpoint])
        n2 = parse(Int, repr(n)[midpoint+1:end])
        n_generated[1] = 2
        n_generated[2:end] = expandstone(n1, depth+1, cache, cache_lock) .+
                             expandstone(n2, depth+1, cache, cache_lock)
    else
        n_generated[1] = 1
        n_generated[2:end] = expandstone(n*2024, depth+1, cache, cache_lock)
    end

    lock(cache_lock) do
        for i_blink in 1:n_blinks
            if (n,i_blink) ∉ keys(cache)
                cache[(n,i_blink)] = n_generated[i_blink]
            end
        end
    end
    return n_generated
end

function main()
    stones = nothing
    open("day11b_input.txt", "r") do f
        while ! eof(f)
            stones = parse.(Int, split(readline(f)))
        end
    end

    n_stones = Threads.Atomic{Int}(0)
    cache = Dict{Tuple{Int,Int},Int}()
    cache_lock = ReentrantLock()
    Threads.@threads for stone in stones
        n_generated = expandstone(stone, 0, cache, cache_lock)
        Threads.atomic_add!(n_stones, n_generated[end])
    end

    println(n_stones[])
end

main()